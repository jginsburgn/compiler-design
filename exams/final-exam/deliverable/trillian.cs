/*
Author:
	Jonathan Ginsburg A01021617
*/

using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace Trillian {

	class CILGenerator {

		public CILGenerator() { }

		public string ObtainAssembly(Node ast) {
			return "// Code generated by the trillian compiler.\n\n" 
				+ ".assembly 'trillian' {}\n\n"
				//+ ".assembly extern 'bcuplib' {}\n\n"
				+ ".class public 'TrillianProgram' extends " 
				+ "['mscorlib']'System'.'Object' {\n" 
				+ "\t.method public static void 'start'() {\n" 
				+ "\t\t.entrypoint\n"
				+ Visit((dynamic) ast)
				+ "call void ['mscorlib']'System'.'Console'::'WriteLine'(float64)\n"
				+ "\t\tret\n"
				+ "\t}\n"
				+ "}\n";
		}

		public string Visit(NMax nMax) {
			string retVal = Visit((dynamic) nMax[0]);
			for (int i = 1; i < nMax.children.Count; ++i){
				retVal += Visit((dynamic) nMax[i]);
				retVal += "\t\tcall float64 ['mscorlib']'System'.'Math'::'Max'(float64, float64)\n";
			}
			return retVal;
		}

		public string Visit(NSummation nSummation) {
			string retVal = Visit((dynamic) nSummation[0]);
			for (int i = 1; i < nSummation.children.Count; ++i){
				retVal += Visit((dynamic) nSummation[i]);
				retVal += "\t\tadd\n";
			}
			return retVal;
		}

		public string Visit(NDuplicate nDuplicate) {
			string retVal = Visit((dynamic) nDuplicate[0]);
			retVal += "\t\tdup\n";
			retVal += "\t\tadd\n";
			return retVal;
		}

		public string Visit(NLiteral nLiteral) {
			string retVal = "\t\tldc.r8 " + nLiteral.AnchorToken.Lexeme + "\n";
			return retVal;
		}
	}

	public class Driver {

		const string VERSION = "0.0";

		//-----------------------------------------------------------
		static readonly string[] ReleaseIncludes = {
			"Lexical analysis",
			"Syntactic analysis",
			"AST construction",
			"Code generation"
		};

		//-----------------------------------------------------------
		void PrintAppHeader() {
			Console.WriteLine("Trillian compiler " + VERSION);
			Console.WriteLine("JGN."
			);
		}

		//-----------------------------------------------------------
		void PrintReleaseIncludes() {
			Console.WriteLine("Included in this release:");
			foreach (var phase in ReleaseIncludes) {
				Console.WriteLine("   * " + phase);
			}
		}

		//-----------------------------------------------------------
		void Run(string[] args) {

			PrintAppHeader();
			Console.WriteLine();
			PrintReleaseIncludes();
			Console.WriteLine();

			if (args.Length != 1) {
				Console.Error.WriteLine(
					"Please specify the name of the input file.");
				Environment.Exit(1);
			}

			try {
				var inputPath = args[0];
				var input = args[0];

				Console.WriteLine(String.Format(
					"===== Tokens from: \"{0}\" =====", inputPath)
				);
				var count = 1;
				foreach (var tok in new Scanner(input).Start()) {
					Console.WriteLine(String.Format("[{0}] {1}",
													count++, tok)
					);
				}

				var parser = new Parser(new Scanner(input).Start().GetEnumerator());
				var program = parser.Program();
				Console.WriteLine("Syntax Ok.");
				Console.Write(program.ToStringTree());
				var cilGenerator = new CILGenerator();
				File.WriteAllText(
					"output.il",
					cilGenerator.ObtainAssembly(program));
			}
			catch (Exception e) {
				if (e is FileNotFoundException || e is SyntaxError) {
					Console.Error.WriteLine(e.Message);
					Environment.Exit(1);
				}
				throw;
			}
		}

		//-----------------------------------------------------------
		public static void Main(string[] args) {
			new Driver().Run(args);
		}
	}

    class Node: IEnumerable<Node> {
        public IList<Node> children = new List<Node>();

        public Node this[int index] {
            get {
                return children[index];
            }
        }

        public Token AnchorToken { get; set; }

        public void Add(Node node) {
            children.Add(node);
        }

        public IEnumerator<Node> GetEnumerator() {
            return children.GetEnumerator();
        }

        System.Collections.IEnumerator
                System.Collections.IEnumerable.GetEnumerator() {
            throw new NotImplementedException();
        }

        public override string ToString() {
            return String.Format("{0} {1}", GetType().Name, AnchorToken);
        }

        public string ToStringTree() {
            var sb = new StringBuilder();
            TreeTraversal(this, "", sb);
            return sb.ToString();
        }

        static void TreeTraversal(Node node, string indent, StringBuilder sb) {
            sb.Append(indent);
            sb.Append(node);
            sb.Append('\n');
            foreach (var child in node.children) {
                TreeTraversal(child, indent + "  ", sb);
            }
        }
    }

	class Parser {

		IEnumerator<Token> tokenStream;

		public Parser(IEnumerator<Token> tokenStream) {
			this.tokenStream = tokenStream;
			this.tokenStream.MoveNext();
		}

		public TokenCategory CurrentToken {
			get { return tokenStream.Current.Category; }
		}

		public Token Expect(TokenCategory category) {
			if (Environment.GetEnvironmentVariable("VERBOSE") == "true") {
				Console.WriteLine("Expecting: " + tokenStream.Current.Lexeme);
				Console.WriteLine(System.Environment.StackTrace);
			}
			if (CurrentToken == category) {
				if (Environment.GetEnvironmentVariable("verbose") == "true") {
					Console.WriteLine("Consuming: " + tokenStream.Current.Lexeme);
				}
				Token current = tokenStream.Current;
				tokenStream.MoveNext();
				return current;
			}
			else {
				if (Environment.GetEnvironmentVariable("verbose") == "true") {
					Console.WriteLine("Not consuming: " + tokenStream.Current.Lexeme);
				}
				throw new SyntaxError(category, tokenStream.Current);
			}
		}

		// Grammar entry point
		public Node Program() {
			Node retVal = Max();
			Expect(TokenCategory.EOF);
			return retVal;
		}

		public Node Max() {
			Node retVal = Simple();
			if (CurrentToken == TokenCategory.BANG) {
				NMax nMax = new NMax();
				nMax.Add(retVal);
				retVal = nMax;
			}
			while (CurrentToken == TokenCategory.BANG) {
				Expect(TokenCategory.BANG);
				retVal.Add(Simple());
			}
			return retVal;
		}

		public Node Simple() {
			switch (CurrentToken) {
				case TokenCategory.LITERAL: {
					NLiteral nLiteral = new NLiteral();
					nLiteral.AnchorToken = Expect(TokenCategory.LITERAL);
					return nLiteral;
				}
				case TokenCategory.ASTERISK: {
					NDuplicate nDuplicate = new NDuplicate();
					nDuplicate.AnchorToken = Expect(TokenCategory.ASTERISK);
					nDuplicate.Add(Simple());
					return nDuplicate;
				}
				case TokenCategory.SQUARE_BRACKET_LEFT: {
					NSummation nSummation = new NSummation();
					nSummation.AnchorToken = Expect(TokenCategory.SQUARE_BRACKET_LEFT);
					MaxList(nSummation);
					Expect(TokenCategory.SQUARE_BRACKET_RIGHT);
					if (nSummation.children.Count == 1) {
						return nSummation[0];
					}
					return nSummation;
				}
				default: {
					Console.WriteLine(CurrentToken);
					throw new Exception("This code should never be reached.");
				}
			}
		}

		public void MaxList(Node parent) {
			parent.Add(Max());
			while (CurrentToken == TokenCategory.COMMA) {
				Expect(TokenCategory.COMMA);
				parent.Add(Max());
			}
		}
	}

    class Scanner {

        readonly string input;

        static readonly Regex regex = new Regex(
            @"
                (?<Literal>     -?[0-9]+(\.[0-9]+)?       )
              | (?<Asterisk>        [*]       )
              | (?<Bang>    [!]       )
              | (?<SquareBracketLeft>    [[]       )
              | (?<SquareBracketRight>   [\]]       )
              | (?<Comma>      [,]       )
              | (?<NewLine>     \n       )
              | (?<WhiteSpace> \s        )     # Must go anywhere after Newline.
              | (?<Unknown>      .         )     # Must be last: match any other character.
            ",
            RegexOptions.IgnorePatternWhitespace
                | RegexOptions.Compiled
                | RegexOptions.Multiline
            );

        public Scanner(string input) {
            this.input = input;
        }

        public IEnumerable<Token> Start() {

            var row = 1;
            var columnStart = 0;

            Func<Match, TokenCategory, Token> newTok = (m, tc) =>
                new Token(m.Value, tc, row, m.Index - columnStart + 1);

            foreach (Match m in regex.Matches(input)) {
                if (m.Groups["NewLine"].Success) {
                    // Found a new line.
                    row++;
                    columnStart = m.Index + m.Length;
                } 
                else if (m.Groups["WhiteSpace"].Success) {
                    // Skip white space and comments.
                } 
                else if (m.Groups["Literal"].Success) {
                    yield return newTok(m, TokenCategory.LITERAL);
                }
                else if (m.Groups["Asterisk"].Success) {
                    yield return newTok(m, TokenCategory.ASTERISK);
                }
                else if (m.Groups["Bang"].Success) {
                    yield return newTok(m, TokenCategory.BANG);
                }
                else if (m.Groups["SquareBracketLeft"].Success) {
                    yield return newTok(m, TokenCategory.SQUARE_BRACKET_LEFT);
                }
                else if (m.Groups["SquareBracketRight"].Success) {
                    yield return newTok(m, TokenCategory.SQUARE_BRACKET_RIGHT);
                }
                else if (m.Groups["Comma"].Success) {
                    yield return newTok(m, TokenCategory.COMMA);
                }
                else if (m.Groups["Unknown"].Success) {
                    // Found an illegal character.
                    yield return newTok(m, TokenCategory.UNKNOWN);
                }
                else {
                    // Supposedly unreachable code.
                    throw new Exception("This code should never be reached.");
                }
            }

            yield return new Token(null,
                                   TokenCategory.EOF,
                                   row,
                                   input.Length - columnStart + 1);
        }
    }

    class NMax: Node {}

    class NSimple: Node {}

    class NDuplicate: Node {}

    class NSummation: Node {}

	class NLiteral: Node {}

    class SyntaxError: Exception {

        public SyntaxError(TokenCategory expectedCategory,
                           Token token):
            base(String.Format(
                "Syntax Error: Expecting {0} \n" +
                "but found {1} (\"{2}\") at row {3}, column {4}.",
                expectedCategory,
                token.Category,
                token.Lexeme,
                token.Row,
                token.Column)) {
        }

        public SyntaxError(ISet<TokenCategory> expectedCategories,
                           Token token):
            base(String.Format(
                "Syntax Error: Expecting one of {0}\n" +
                "but found {1} (\"{2}\") at row {3}, column {4}.",
                Elements(expectedCategories),
                token.Category,
                token.Lexeme,
                token.Row,
                token.Column)) {
        }

        static string Elements(ISet<TokenCategory> expectedCategories) {
            var sb = new StringBuilder("{");
            var first = true;
            foreach (var elem in expectedCategories) {
                if (first) {
                    first = false;
                } else {
                    sb.Append(", ");
                }
                sb.Append(elem);
            }
            sb.Append("}");
            return sb.ToString();
        }
    }

    enum TokenCategory {
      LITERAL,
      ASTERISK,
      BANG,
      SQUARE_BRACKET_LEFT,
      SQUARE_BRACKET_RIGHT,
      COMMA,
      UNKNOWN,
      EOF
    }

    class Token {

        readonly string lexeme;

        readonly TokenCategory category;

        readonly int row;

        readonly int column;

        public string Lexeme {
            get { return lexeme; }
        }

        public TokenCategory Category {
            get { return category; }
        }

        public int Row {
            get { return row; }
        }

        public int Column {
            get { return column; }
        }

        public Token(string lexeme,
                     TokenCategory category,
                     int row,
                     int column) {
            this.lexeme = lexeme;
            this.category = category;
            this.row = row;
            this.column = column;
        }

        public override string ToString() {
            return string.Format("{{{0}, \"{1}\", @({2}, {3})}}",
                                 category, lexeme, row, column);
        }
    }
}